---
title: 动态规划
date: 2019-04-27 19:24:50
tags:
- 经典算法
---

### 动态规划算法

##### 算法思想

动态规划算法常用来求解最优化问题，这类问题可以有很多可行解，我们希望找到这些可行解中具有最优值的解。动态规划常用于子问题重叠的情况，即不同的子问题拥有共同的子子问题，这时将共同的子子问题保存起来，减少运算次数。

动态规划通过仔细安排求解顺序，对每个子问题只求解一次，并将结果保存下来，如果随后再次需要此问题的解，只需要查找保存的结果，无需重复计算，因此，动态规划付出额外的内存空间来节省计算时间，是典型的时空权衡。

动态规划的实现一般有两种，**带备忘录的自顶向下方法**，此算法在求解顺序仍按原自然顺序，但会将子问题的解保存，当需要某问题的解时，先去“备忘录”检查是否有值，有则直接获取，否则再计算。

另一种方法是**自底向上法**，此方法一般需要恰当定义子问题“规模”的概念，使得任何子问题的求解只依赖于更小的子问题，因此可以通过安排求解顺序，从小至大求解，这样在求解大问题时，小问题已经全部解决。

两种方法具有相近的渐进时间复杂度，仅有的差异是备忘录法某些情况下未能递归地考察所有子问题，而自底向上法通常具有更小的时间复杂度系数。

<!--more-->

##### 斐波那契数列

```java
import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;
import java.util.Stack;

/**
**Fibnacci算法
 *备忘录法
 */
public class Main {
    public static void main(String[] args) {
        for (int i = 0; i <10 ; i++) {
            System.out.println(Fibnacci(i));
        }
    }
    //备忘录法，自上而下
    public static int Fibnacci(int n) {
        if(n<=0)
            return n;
        int[] memo = new int[n+1];//将以求过的值保存起来
        return fib(n,memo);
    }
    private static int fib(int n,int[] memo){
        if(memo[n]!=0)return memo[n];
        if(n<=2){
            memo[n] = 1;
        }else {
            memo[n] = fib(n-1,memo)+fib(n-2,memo);
        }
        return memo[n];
    }
}
//自底向上方法
    public static int Fibnacci(int n) {
        if(n<=0)
            return n;
        int m1 = 1;
        int m2 = 1;
        int tmp = 0;
        for (int i = 2; i <=n; i++) {
            tmp = m2;
            m2 = m1+m2;
            m1 = tmp;
        }
        return m1;
    }

```

##### 算法实例应用：钢条切割


```java
import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;
import java.util.Stack;

/**
**动态规划
 *切割钢条问题
 */
public class Main {
    public static void main(String[] args) {
        int[] arr = new int[]{0,1,5,8,9,10,17,17,20,24,30};
        System.out.println(cutRod3(6,arr));
    }
    //递归版本，当问题规模太大时，效率会变差
    public static int cutRod(int n,int[] arr) {
        if(n==0)
            return 0;
        int q = Integer.MIN_VALUE;
        for (int i = 1; i <= n; i++) {
            q = Math.max(q,arr[i]+cutRod(n-i,arr));
        }
        return q;
    }
    //动态规划版本
    //1.备忘录法
    public static int cutRod2(int n,int[] arr){
        if(n==0)
            return 0;
        int[] bwl = new int[arr.length];//备忘录
        return getRod(n,bwl,arr);
    }
    private static int getRod(int n,int[] bwl,int[] arr){
        if(bwl[n]!=0)return bwl[n];//有记录则直接返回，避免重复计算
        if(n==0)return 0;
        int q = Integer.MIN_VALUE;
        for (int j = 1; j <=n; j++) {
            q = Math.max(q,arr[j]+getRod(n-j,bwl,arr));
        }
        bwl[n] = q;
        return q;
    }
    //2.自底向上法
    public static int cutRod3(int n,int[] arr){
        if(n==0)
            return 0;
        int[] r = new int[n+1];
        for (int i = 1; i <=n; i++) {
            int q = Integer.MIN_VALUE;
            for (int j = 1; j <= i ; j++) {
                q = Math.max(q,arr[j]+r[i-j]);
            }
            r[i] = q;
        }
        return r[n];
    }
}


```

*内容案例参考《算法导论》*

