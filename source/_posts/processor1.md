---
title: 进程的描述与控制（上篇）
url: 25.html
id: 25
categories:
  - 基础课程收录
  - 操作系统
date: 2018-04-10 01:01:53
tags:
---

### 进程的描述与控制

#### 为什么引入进程

首先了解下程序并发执行（同一时间间隔内运行多个程序，在一个程序结束之前就可以运行其他程序）的特点：

1.  间断性（程序通常是时断时续地来执行）
    
2.  失去封闭性（程序的环境变量不再是封闭不可见的，是共享的，如全局变量）
    
3.  不可再现性（由于失去了封闭性，使得执行结果不可再现，如全局变量）
    

**为了跟踪并描述程序的并发执行，引入了进程的概念。** 当并发执行的时候，有可能是同一程序对不同资源的执行，也可能是不同程序对不同资源的执行，它们共享系统资源，用程序已经不能准确描述并发执行的过程。 比如同一程序在不同的数据集合上运行，那么如果用程序直接来描述的话，很容易产生这些程序是不同的错觉，这时候我们引入进程这一概念，就可以很好地去描述这些情况。

#### 什么是进程

1.  进程是程序在一个数据集合上的**运行过程**
    
2.  进程是由程序，用户数据，系统数据共同组成的一个**执行环境** ——各种指令和数据，额外数据
    
3.  **进程表示的就是执行环境的状态，执行环境的动态变化的过程**
    
4.  进程的特征：
    
    *   并发性
        
    *   动态性（进程表示的是执行**过程** ，进程状态，进程映像（某一时刻进程的内容）的变化）
        
    *   独立性
        
    *   异步性
        
    *   结构特征——程序，用户数据，系统数据
        

#### 进程与程序的区别与联系

1.  程序是静态的——有序的指令集合，进程是动态的——对应着程序执行的过程
    
2.  程序是永久的，进程是暂时存在的
    
3.  **二者的存在实体不同**，程序是指令集合，进程则是包含了用户正文段、系统数据段、用户数据段的实体
    
4.  联系
    
    *   进程是程序的一次执行，至少对应一个程序
        
    *   一个程序可对应多个进程，同一进程可顺序执行多个程序
        

#### 进程控制块（PCB）的概念

系统在创建进程的时候，为进程开辟了一个专用的存储区，用来记录操作系统所需要的用于描述进程及控制进程运行所需的全部信息。 特征：

*   每个进程有唯一 的进程控制块
    
*   进程控制块是操作系统感知进程存在的唯一标志
    
*   进程控制块常驻内存
    
*   进程控制块在内核层
    

linux的进程控制块：

struct task_struct{
volatile long state;-info
struct thread_info*thread
}

Windows：执行体进程块(EPROCESS) 进程控制块中的信息

*   进程标识符
    
    *   内部标识符（操作系统分配，用于标识进程）
        
    *   外部标识符（由创建者提供，通常有字母和数字组成）
        
*   处理机状态
    
    硬件上下文，以便进程可以重新从断点执行——通用寄存器、指令计数器、程序状态字psw、用户栈指针
    
*   进程调度信息
    
    进程状态、进程优先级、所需的其他信息、事件
    
*   进程控制信息
    
    程序和数据地址、进程同步和通信机制、资源清单、链接指针（本进程队列下一个pcb的地址）
    
    ![](file://C:/Users/Boolean/Documents/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/pcb_po.png?lastModify=1523293230)
    

##### 进程的基本状态

1.  就绪状态
    
    进程一旦获得CPU就可以投入运行的状态（根据优先权，分成多个就绪队列）
    
2.  执行状态
    
    进程获得CPU正在运行的状态
    
3.  阻塞状态
    
    进程由于等待资源或由于某个事件的发生而暂停执行的状态（根据不同阻塞原因分成多个阻塞队列，便于唤醒）
    
    ![](file://C:/Users/Boolean/Documents/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/pcb_state.png?lastModify=1523293230)
    

##### 进程控制块的组织方式

1.  线性方式——把所有PCB组织在一张线性表中，将该表的首地址存放在内存的一个专用区域中，每次查找是需要扫描全表，适用于进程数不多的情况
    
2.  链接方式——把**具有同一状态**的PCB，用其中的链接字链接成一个**队列**，PCB存储在**一个连续的存区**
    
    ![](file://C:/Users/Boolean/Documents/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/pcb_link.png?lastModify=1523293230)
    
3.  索引方式——各个索引表在内存单元中的首地址也记录在内存中的专用单元中，用添加索引表的方式记录具有相应状态下的某个PCB在PCB表中的地址。
    
    ![](file://C:/Users/Boolean/Documents/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/pcb_suoy.png?lastModify=1523293230)
    

##### 常见的进程调度算法

1.  **先来先服务（FCFS）**
    
    算法描述：按照进程请求CPU的顺序来进行调度，谁第一个排，谁第一个执行
    
    算法优点：实现简单
    
    算法缺点：利于长进程，而不利于短进程，有利于CPU繁忙的进程，而不利于I/O繁忙的进程
    
2.  **最短作业优先（SJF）**
    
    算法描述：对预计执行时间短的进程优先分派处理机
    
    算法优点：相比FCFS，提高了系统吞吐量，缩短了进程的等待时间
    
    算法缺点：对长进程非常不利，可能长时间得不到执行，且未能按照紧迫度划分优先级
    
3.  **最高响应比优先法（HRRN）**
    
    算法描述：综合考虑每个作业的等待时间及估计需要执行时间的长短，从中选出响应比（R=（W+T）/T）最高的作业投入运行
    
    算法优点：长进程也可以得到执行
    
    算法缺点：由于每次调度前要计算响应比，系统开销也会增加
    
4.  **时间片轮转算法（RR）**
    
    算法描述：让就绪进程以FCFS的方式按时间片轮流使用CPU的调度方式，即将系统中所有的就绪进程按照FCFS原则，排成一个队列，每次调度时将cpu分派给队首进程，让其执行一个时间片（cpu允许执行的时间）。时间片的长度从几个ms到几百ms。在一个时间片结束时，发生时钟中断，调度程序按此暂停当前进程的执行，将其送至就绪队列的末尾，并通过上下文切换执行当前的队首进程，进程也可以未完成一个时间片，就让出cpu
    
    算法优点：简单易行？、平均响应时间短（每个进程都执行一个时间片，那么，所有进程获得响应的时间就会减少）
    
    算法缺点：不利于处理紧急作业
    
    **时间片的确定：**系统对响应时间的要求、就绪队列中进程的数目、系统的处理能力
    
5.  **多级反馈队列（MFQ）**
    
    1.  进程在进入待调度的队列等待时，首先进入优先级最高的Q1等待。
        
    2.  首先调度优先级高的队列中的进程。若高优先级中队列中已没有调度的进程，则调度次优先级队列中的进程。例如：Q1,Q2,Q3三个队列，只有在Q1中没有进程等待时才去调度Q2，同理，只有Q1,Q2都为空时才会去调度Q3。
        
    3.  对于同一个队列中的各个进程，按照时间片轮转法调度。比如Q1队列的时间片为N，那么Q1中的作业在经历了N个时间片后若还没有完成，则进入Q2队列等待，若Q2的时间片用完后作业还不能完成，一直进入下一级队列，直至完成。
        
    4.  在低优先级的队列中的进程在运行时，又有新到达的作业，那么在运行完这个时间片后，CPU马上分配给新到达的作业（抢占式）
        
        **在多级反馈队列调度算法中，如果规定第一个队列的时间片略大于多数人机交互所需之处理时间时，便能够较好的满足各种类型用户的需要。**
        
    
    #### 进程的控制
    
    1.  进程的创建
        
        *   申请空白的PCB
            
        *   为新进程分配资源
            
        *   初始化进程控制块
            
        *   将新进程插入就绪队列
            
        
        进程创建的情况：
        
        *   用户登录
            
        *   作业调度
            
        *   提供服务
            
        *   应用请求
            
    2.  进程的阻塞
        
        *   请求系统服务
            
        *   启动某种操作
            
        *   新数据尚未到达
            
        *   无新工作可做
            
        
        阻塞过程：
        
        *   暂停进程的执行，将状态改为阻塞态
            
        *   将进程插入阻塞队列
            
        *   转进程调度例程，重新进行进程调度
            
    3.  进程的唤醒
        
        *   将进程从阻塞队列中移出
            
        *   将状态由阻塞改为就绪
            
        *   将进程插入就绪队列
            
    4.  进程的终止
        
        引起终止的事件：
        
        *   正常结束
            
        *   异常结束
            
        *   外界干预
            
        
        终止的过程：
        
        *   从进程PCB当中读进程状态
            
        *   若进程正在执行则终止进程的执行
            
        *   若进程有子孙进程则终止子孙进程
            
        *   释放资源
            
        *   将终止进程的PCB移出