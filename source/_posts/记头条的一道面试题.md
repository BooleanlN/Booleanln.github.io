---
title: 记头条的一道面试题
date: 2019-06-23 14:21:37
tags:
- 面试
- javaScript
---

### 一道面试题

前几天，参加了两场面试，一个是字节跳动，也就是头条，一个是网易云音乐，面试岗位都是前端。

两个面试都超过了一小时，不管结果如何，都通过这两次面试认识到了自己的短板。

这里记一道面试题。

<!--more-->

##### 题目

使用javaScript的OOP语法，创建一个Flow类，这个类内有两个函数，一个是注册函数register，另一个是next函数，该函数会打印出当前运行的任务。

```js
register (key, callback) {
	
}
next (key) {
	
}
let flow = new Flow()
flow.register('task 1', () => {
	console.log('run task 1')
})register('task 2', () => {
	console.log('run task 2')
}).register('task 3', () => {
	console.log('run task 3')
})register('task 4', () => {
	console.log('run task 4')
})
flow.next('task 1').next('task 2') // run task 1 run task 2
flow.next('task 3').next('task 1') // run task 3 run task 1

flow.next('task 3').next('task 1').next('task 3').next('task 1')
// run task 3 run task 1 run task 3 run task 1
```

面试时给出的答案（面试官给我降低了难度）

```js
function Flow(){
    this.callbackFunc = {}
    this.runFunc = []
    this.startIndex = 0,
    this.register = function (key, callback) {
        this.callbackFunc[key] = callback
        return this
    },
    this.next = function (key) {
    	this.runFunc.push(this.callbackFunc[key])
        return this
    },
    this.run = function () {
    	this.runFunc.forEach((item,index) => {
    		if(index>=this.startIndex)
    		{
    			item()
    			this.startIndex ++
    		}
    	})
   }
}
// 借助一个run函数实现，其实没必要，当时脑子糊了
```

ES6写法

```js

class Flow{
	callbackFunc = {}
	register(key, callback){
		this.callbackFunc[key] = callback
		return this
	}
	next(key){
		this.callbackFunc[key]()
		return this
	}
}

let flow = new Flow()
flow.register('task 1', () => {
    console.log('run task 1')
}).register('task 2', () => {
    console.log('run task 2')
}).register('task 3', () => {
    console.log('run task 3')
})
flow.next('task 1').next('task 2')
flow.next('task 3').next('task 1')

flow.next('task 3').next('task 1').next('task 3').next('task 1')
```

这道题主要考察了javaScript当中的面向对象编程以及链式调用的实现。

javaScript的面向对象在ES5之前，主要通过原型模式实现。

在函数对象中，会有一个原型对象的属性，如Object构造函数等，都包含一个原型属性，该属性指向一个原型对象，在原型对象中，必然包含一个constructor属性，该属性指向该构造函数。

```js
Flow.prototype.constructor === Flow // true	
```

该Flow类的实例是一个Object对象，几乎所有的对象都含有一个`__proto__`属性，该属性指向Flow类的原型对象，即

```js
flow.__proto__ === Flow.prototype // true
```

如果Function构造函数实现封装，通过原型链实现继承和多态。

```js
function SubFlow () {
    // 多态
	this.next = function (key) {
		console.log('subnext')
    	this.runFunc.push(this.callbackFunc[key])
        return this
    }  
}
SubFlow.prototype = new Flow() // 继承
```

js引擎在解析时，会顺着原型链一直往上找，直到`Object.prototype.__proto__`为null

在ES6中，则通过class来实现面向对象，class其实是一个语法糖，它的本质仍然是构造函数。

###### 链式调用

链式调用的实现原理即是将this作为返回，则对于下一个函数来说，是由上一个函数设置过的对象进行调用的。