---
title: 最长回文子串
date: 2019-04-23 17:26:16
tags:
 - leetcode
 - 经典算法
---

### 最长回文子串

给定一个字符串 `s`，找到 `s` 中最长的回文子串。你可以假设 `s` 的最大长度为 1000。

**示例 1：**

```
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
```

**示例 2：**

```
输入: "cbbd"
输出: "bb"
```

<!--more-->

#### answer：

```java
//1.暴力解法，O(n^3)，超出时间限制
import java.util.*;

/**
**
 *
 */
public class Main {
    public static void main(String[] args){
            String s = "abba";
        System.out.println(longestPalindrome(s));
    }
    public static String longestPalindrome(String s) {
        int longest = 1;
        if(s.length()<=1)return s;
        String res = s.substring(0,1);
        for (int i = 0; i < s.length(); i++) {
            for (int j = i+1; j < s.length()+1 ; j++) {
                String str = s.substring(i,j);
                //System.out.println(str);
                if(str.equals(StrInverse(str))&&str.length()>longest){
                    longest = str.length();
                    res = str;
                }
            }
        }
        return res;
    }
    private static String StrInverse(String str){
        StringBuilder ss = new StringBuilder();
        for (int i = str.length()-1; i >= 0 ; i--) {
            ss.append(str.charAt(i));
        }
        return ss.toString();
    }
}
```

```java
//2.中心拓展算法 O(n^2)
class Solution {
    public String longestPalindrome(String s) {
          if(s.length()<=1)return s;
        int start = 0,end = 0;
        for (int i = 0; i < s.length(); i++) {
          int len1 = expandAroundCenter(s,i,i);
          int len2 = expandAroundCenter(s,i,i+1);
          int len = Math.max(len1,len2);
          if(end-start<len){
              start = i - (len-1)/2;
              end = i+len/2;
          }
        }
        return s.substring(start,end+1);
    }
    private static int expandAroundCenter(String s,int left,int right){
        int i = left,j=right;
        while (i>=0&&j<s.length()&&(s.charAt(i)==s.charAt(j))){
            i--;
            j++;
        }
        return j - i - 1;
    }
}
```

```java
//macher方法
//马拉车算法
//bob->#b#o#b#
//radis = [1,2,1,4,1,2,1]
//则结果最长回文串长度为4-1 = 3
//R记录当前最长回文串最右边下标
//C记录当前最长回文串中心点下标
//若遍历下标i在R左边，则可以通过与i以C为对称点的对称下标的回文半径作比较：
     //1.若i对称点的最左边界下标<当前最长回文串最左下标,即代表(radis[i对称下标])小于(长度R-i)，则说明，该回文串在当前最大回文串内部，则radis[i]:=radis[i对称下标]
	//2.若radis[i对称下标]>=当前最长回文串最左下标，则说明radis[i]目前最大可以赋值为R-i,然后再通过
	//while循环，获得最终的回文半径radis[i]
//若遍历下标i在R右边，则通过while循环匹配
public static String longestPalindrome(String s) {
        if(s.length()<=1)return s;
        //字符串插入'#'，使得回文串都变成奇数个
        char[] charArr = manacher(s);
        //回文半径数组
        int[] radis  = new int[charArr.length];
        int R = -1;//最长回文串右边界
        int C = -1;//最长回文串中心点
        int max = Integer.MIN_VALUE;
        int start = 0;//最长回文串左边界
        for (int i = 0; i < charArr.length ; i++) {
            //manacher核心
            radis[i] = R>i?Math.min(R-i,radis[2*C-i]):1;
            //匹配
            while (i+radis[i]<charArr.length&&i-radis[i]>=0&&charArr[i-radis[i]]==charArr[i+radis[i]]){
                radis[i]++;
            }
            //更新中心点，右边界
            if(radis[i]>R)
            {
                R = i+radis[i]-1;
                C = i;
            }
            //更新最大值，左边界
            start = max>radis[i]?start:(i-radis[i]+1)/2;
            max = Math.max(max,radis[i]);
        }
        return s.substring(start,start+max-1);
    }
    private static char[] manacher(String s){
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < s.length() ; i++) {
            builder.append("#");
            builder.append(s.charAt(i));
        }
        builder.append("#");
        return builder.toString().toCharArray();
    }
//该算法时间复杂度应该为O(n),因为manacher核心句为O(1),若执行while循环时，R内的位置不会再次判断，R的移动是从起点一直到终点，为O(n),所以manacher为O(n),空间复杂度为O(2*n)
```

